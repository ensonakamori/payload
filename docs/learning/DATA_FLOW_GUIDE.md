# Data Flow Guide

**Documented:** November 18, 2025

Understanding how data moves through Payload CMS from request to response.

## Request Lifecycle Overview

```
1. HTTP Request arrives
   ↓
2. Next.js Router matches route
   ↓  
3. Server Component or Route Handler executes
   ↓
4. Payload operation called
   ↓
5. Hooks execute (beforeValidate, beforeChange, etc.)
   ↓
6. Access control checked
   ↓
7. Database adapter called
   ↓
8. Database executes query
   ↓
9. Response flows back up
   ↓
10. Hooks execute (afterRead, afterChange, etc.)
    ↓
11. Response sent to client
```

## Flow 1: Creating a Document (Admin Panel)

**User Action:** Fills out form and clicks "Save" in admin panel

**Detailed Flow:**

```
Browser
  │ 1. Form submission via Server Action
  ↓
Server Action Handler
  │ 2. Extracts form data
  │ 3. Calls: payload.create({ collection, data })
  ↓
Payload Core (packages/payload/src/collections/operations/create.ts)
  │ 4. beforeValidate hooks
  │ 5. Field validation
  │ 6. beforeChange hooks  
  │ 7. Access control (canCreate permission)
  │ 8. Transforms data for database
  ↓
Database Adapter (packages/db-*/src/)
  │ 9. Converts Payload format → Database format
  │ 10. Executes database insert
  ↓
Database (MongoDB/Postgres/SQLite)
  │ 11. Stores document
  │ 12. Returns inserted document with ID
  ↓
Response flows back up
  │ 13. afterChange hooks execute
  │ 14. afterRead hooks execute (to format response)
  ↓
Server Action
  │ 15. revalidatePath() - Clear Next.js cache
  │ 16. redirect() - Navigate to edit page
  ↓
Browser
  │ 17. Shows success message
  │ 18. Displays newly created document
```

**Key Files:**
- Operation: `packages/payload/src/collections/operations/create.ts`
- Types: `packages/payload/src/collections/operations/local/create.ts`

## Flow 2: Reading Documents (REST API)

**Request:** `GET /api/posts?limit=10&page=1`

```
HTTP GET Request
  ↓
Next.js Route Handler (app/api/posts/route.ts)
  │ Generated by Payload
  ↓
Payload REST Handler (packages/next/src/routes/)
  │ 1. Parses query parameters
  │ 2. Authenticates request (if auth collection)
  │ 3. Calls: payload.find({ collection, where, limit, page })
  ↓
Payload Core (packages/payload/src/collections/operations/find.ts)
  │ 4. beforeRead hooks
  │ 5. Access control (canRead permission)
  │ 6. Builds query object
  ↓
Database Adapter
  │ 7. Transforms Payload query → Database query
  │ Example MongoDB: { status: 'published' } → { status: { $eq: 'published' } }
  │ Example Postgres: { status: 'published' } → WHERE status = 'published'
  ↓
Database
  │ 8. Executes query
  │ 9. Returns array of documents
  ↓
Response flows back
  │ 10. afterRead hooks (can modify docs)
  │ 11. Formats as PaginatedDocs
  ↓
REST Handler
  │ 12. Converts to JSON
  │ 13. Sets HTTP headers
  ↓
HTTP Response
{
  "docs": [...],
  "totalDocs": 42,
  "limit": 10,
  "page": 1,
  ...
}
```

## Flow 3: GraphQL Query

**Query:**
```graphql
query {
  Posts(limit: 5) {
    docs { id, title }
  }
}
```

```
POST /api/graphql
  ↓
GraphQL Server (graphql-http)
  │ 1. Parses query
  │ 2. Validates against schema
  ↓
GraphQL Resolver (Payload-generated)
  │ 3. Calls: payload.find({ collection: 'posts', limit: 5 })
  ↓
[Same as REST API flow above]
  ↓
GraphQL Resolver
  │ Returns data in GraphQL format
  ↓
Response
{
  "data": {
    "Posts": {
      "docs": [...]
    }
  }
}
```

## Hooks in the Flow

Hooks execute at specific points in the lifecycle:

**beforeValidate** → Before field validation  
**beforeChange** → Before database write  
**afterChange** → After database write  
**beforeRead** → Before reading from database  
**afterRead** → After reading from database  

**Example Hook:**
```typescript
{
  name: 'posts',
  hooks: {
    beforeChange: [
      async ({ data }) => {
        // Auto-set slug from title
        data.slug = data.title.toLowerCase().replace(/\s/g, '-')
        return data
      }
    ]
  }
}
```

## Access Control in the Flow

Checked **before** database operations:

```typescript
{
  name: 'posts',
  access: {
    read: true,  // Anyone can read
    create: ({ req }) => !!req.user,  // Must be logged in
    update: ({ req }) => req.user?.role === 'admin',  // Admin only
  }
}
```

**Flow:**
1. User makes request
2. Payload authenticates user (if needed)
3. Access control function runs
4. If returns `true`, operation continues
5. If returns `false`, throws `Forbidden` error

## Database Query Translation

How Payload queries become database queries:

**Payload Query:**
```typescript
payload.find({
  collection: 'posts',
  where: {
    and: [
      { status: { equals: 'published' } },
      { title: { contains: 'Next.js' } }
    ]
  },
  limit: 10,
  sort: '-createdAt'
})
```

**MongoDB Translation:**
```javascript
db.collection('posts').find({
  $and: [
    { status: { $eq: 'published' } },
    { title: { $regex: 'Next.js', $options: 'i' } }
  ]
}).limit(10).sort({ createdAt: -1 })
```

**PostgreSQL Translation (Drizzle):**
```typescript
db.select()
  .from(posts)
  .where(
    and(
      eq(posts.status, 'published'),
      like(posts.title, '%Next.js%')
    )
  )
  .limit(10)
  .orderBy(desc(posts.createdAt))
```

## Caching & Revalidation

**Next.js 15 Caching:**
- Route Handlers: Uncached by default
- Server Components: Cached by default
- Client Router: Uncached by default

**Revalidation:**
```typescript
import { revalidatePath, revalidateTag } from 'next/cache'

// After mutation
await payload.create({ ... })
revalidatePath('/posts')  // Clear page cache
```

## Performance Optimizations

1. **Depth Parameter** - Control relationship population
   ```typescript
   payload.find({ 
     collection: 'posts',
     depth: 1  // Populate one level of relationships
   })
   ```

2. **Select Fields** - Only fetch needed fields
   ```typescript
   payload.find({
     collection: 'posts',
     select: { title: true, createdAt: true }
   })
   ```

3. **Pagination** - Limit results
   ```typescript
   payload.find({
     collection: 'posts',
     limit: 10,
     page: 1
   })
   ```

## Error Flow

When errors occur:

```
Error thrown anywhere in flow
  ↓
Caught by Payload error handler
  ↓
Mapped to HTTP status code
  - ValidationError → 400
  - Forbidden → 403
  - NotFound → 404
  - AuthenticationError → 401
  ↓
Formatted as JSON response
{
  "errors": [{
    "message": "Forbidden",
    "name": "Forbidden"
  }]
}
```

## Transaction Flow (Postgres)

```
1. payload.create() called
   ↓
2. Adapter begins transaction
   ↓
3. Multiple database operations
   ↓
4. If all succeed: Commit transaction
5. If any fails: Rollback transaction
```

## Next Steps

- [BACKEND_ARCHITECTURE.md](./BACKEND_ARCHITECTURE.md) - Payload operations deep dive
- [DATABASE_ARCHITECTURE.md](./DATABASE_ARCHITECTURE.md) - Database layer details
- [CODE_TOURS.md](./CODE_TOURS.md) - Follow actual code flows

---

*Trace every request, understand every response!*
